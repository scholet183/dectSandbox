/*
 * Copyright (c) 2016-2018 DSP Group, Inc.
 *
 * SPDX-License-Identifier: MIT
 */
#include "Endian.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/// Convert u16 from Host bytes endian to Network endian
u16 p_Endian_hos2net16( u16 u16_Value )
{
    // if little endian... convert as network is big
    if ( ENDIANNESS_IS_LITTLE )
    {
        return p_Endian_Reorder16( u16_Value );
    }
    else
    {
        return u16_Value;
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/// Convert u32 from Host bytes endian to Network endian
u32 p_Endian_hos2net32( u32 u32_Value )
{
    // if little endian... convert as netowrk is big
    if ( ENDIANNESS_IS_LITTLE )
    {
        return p_Endian_Reorder32( u32_Value );
    }
    else
    {
        return u32_Value;
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Convert u16 from Network bytes endian to Host bytes endian
u16 p_Endian_net2hos16( u16 u16_Value )
{
    if ( ENDIANNESS_IS_LITTLE )
    {
        return  p_Endian_Reorder16( u16_Value );
    }
    else
    {
        return u16_Value;
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Convert u32 from Network bytes endian to Host bytes endian
u32 p_Endian_net2hos32( u32 u32_Value )
{
    if ( ENDIANNESS_IS_LITTLE )
    {
        return  p_Endian_Reorder32( u32_Value );
    }
    else
    {
        return u32_Value;
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/// Reorder bytes endian for u16
u16 p_Endian_Reorder16( u16 u16_Value )
{
    return  ( ( ( u16_Value & 0x00FF ) << 8 ) |
              ( ( u16_Value & 0xFF00 ) >> 8 ) );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/// Reorder bytes endian for u32
u32 p_Endian_Reorder32( u32 u32_Value )
{
    return  (   ( ( u32_Value & 0x000000FF ) << 24 ) |
                ( ( u32_Value & 0x0000FF00 ) << 8 )  |
                ( ( u32_Value & 0x00FF0000 ) >> 8 )  |
                ( ( u32_Value & 0xFF000000 ) >> 24 ) );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
